<?php

/**
 * Drago Extension
 * Package built on Nette Framework
 */

declare(strict_types=1);

namespace Drago\Generator\Generator;

use Dibi\Exception;
use Drago\Generator\Base;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpFile;
use Nette\Utils\FileSystem;
use Nette\Utils\Strings;
use Throwable;


/**
 * Generates data class based on database schema.
 */
class DataClassGenerator extends Base implements IGenerator
{
	/**
	 * Runs the generation process for a specific table or all tables.
	 *
	 * @param string|null $table The table name to generate for, or null for all tables.
	 * @throws Exception
	 * @throws Throwable
	 */
	public function runGeneration(?string $table = null): void
	{
		if ($table !== null) {
			$this->createPhpFile($table);
		} else {
			foreach ($this->repository->getTableNames() as $table) {
				$this->createPhpFile($table);
			}
		}
	}


	/**
	 * Creates a PHP file for a given table.
	 *
	 * @param string $table The table name to generate the class for.
	 * @throws Exception
	 * @throws Throwable
	 */
	public function createPhpFile(string $table): void
	{
		// Get options for the generator.
		$options = $this->options;

		// Create the class filename and add suffix.
		$name = $this->filename($table, $options->suffixDataClass);

		// Generate the class.
		$class = new ClassType($name);

		// Add final modifier if required.
		if ($options->finalDataClass) {
			$class->setFinal();
		}

		// Add extends class if required.
		if ($options->extendsOn) {
			$class->setExtends($options->extendsDataClass);
		}

		// Get references for the table.
		$references = $this->getReferencesTable($table);

		// Loop through all columns in the table.
		foreach ($this->repository->getColumnNames($table) as $column) {
			// Convert column name to lowercase if required.
			if ($options->lower) {
				$column = Strings::lower($column);
			}

			// Validate column names for parentheses.
			$this->validateColumn($table, $column);

			// Get column attribute information.
			$attr = $this->repository->getColumn($table, $column);

			// Add constants if required.
			if ($options->constantDataClass) {
				$constant = $options->constantDataPrefix
					? $options->constantDataPrefix . $this->inflector->classify($column)
					: $this->inflector->classify($column);

				$class->addConstant($constant, $column)
					->setPublic();

				// Add constant for column size if required.
				if ($options->constantSizeDataClass && !$attr->isAutoIncrement() && $attr->getSize() > 0) {
					$class->addConstant($constant . 'Size', $attr->getSize())
						->setPublic();
				}
			}

			// Detect the native type for the column.
			$detectType = $this->detectType($attr->getNativeType());

			// Add property for the column.
			$class->addProperty($column)
				->setType($detectType)
				->setNullable($attr->isNullable())
				->setInitialized($attr->isNullable())
				->setPublic();

			// Add reference to another table if required.
			if ($options->referencesDataClass && isset($references[$column])) {
				$filename = $this->filename($references[$column], $options->suffixDataClass);
				$class->addProperty($references[$column])
					->setType($options->namespaceDataClass . '\\' . $filename);
			}
		}

		// Generate the PHP file content.
		$file = new PhpFile;
		$file->addComment('This file was generated by Drago Generator.')
			->setStrictTypes()
			->addNamespace($options->namespace)
			->addUse('Drago')
			->add($class);

		// Write the generated PHP file to the filesystem.
		$path = $options->pathDataClass . '/' . $name . '.php';
		FileSystem::write($path, $file->__toString());
	}
}
